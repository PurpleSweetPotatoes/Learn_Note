# iOS知识点整理

## 响应链

> 所有事件响应的类都是 UIResponder 的子类

事件响应路线
`First Responser --> The Window --> The Application --> nil(丢弃)`

系统检测到手指Touch操作，并将其打包为UIEvent对象放入当前活动Application事件队列

Application会将其传递给UIWindow处理，UIWindow会使用`hitTest:WithEvent:`方法找寻对应的第一响应者

`hitTest:WithEvent:`处理流程:

+ 遍历window子视图，从顶层往底层走
  + 判断子视图`hidden=NO`且`alpha>=0.01`且手势可用且`postionInside:WithEvent:`为真
    + 真 则为第一响应者

遍历完仍未找到第一响应者则按照事件响应路线走

## RunTime

> 动态运行时，解决如何在运行时期找到调用方法
>
> 对于实例变量有如下的思路：
>
> instance -> class -> method -> SEL -> IMP -> 实现函数

### 加载过程

> 懒加载类和非懒加载类的区分很简单，就是看类有没有实现load方法

1. 加载所有类到类的gdb_objc_realized_classes表中
2. 对所有类做重映射
3. 将所有SEL注册到namedSelectors表中
4. 修复函数指针遗留
5. 将所有Protocol都添加到protocol_map表中
6. 对所有Protocol做重映射
7. 初始化所有非懒加载的类，进行rw,ro等操作
8. 遍历已标记的懒加载类，并做初始化操作
9. 处理所有Category，包括Class和Mete Class
10. 初始化所有未初始化的类

### 结构体

其中`class_ro_t`为基本结构体在编译时期确定，所以不能在category中添加成员变量

`class_rw_t`内的其他变量是在后续中将ro中的值赋值生成，会在运行时获取category等相关信息并更新变量

![](http://blog-imgs.nos-eastchina1.126.net/1645077653.png)

![](http://blog-imgs.nos-eastchina1.126.net/1645077658.png)

### isa指向

`class`类对象：存储实例相关的属性或方法(-、proprtey)

`meta class` 类类对象: 存储类相关的属性或方法(+、static、class)

<img src="http://blog-imgs.nos-eastchina1.126.net/1645069288.png" style="zoom:80%;" />

类中的 super_class 指针可以追溯整个继承链。向一个对象发送消息时，Runtime 会根据实例对象的 isa 指针找到其所属的类，并自底向上直至根类(NSObject)中 去寻找 SEL 所对应的方法，找到后就运行整个方法。

### 消息传递机制

> 即`objc_msgSend`函数处理过程

执行流程如下:

1. 检测SEL是否忽略
2. 检测发送的target是否为nil
3. 对应target的class或metaclass中查找方法缓存列表及方法列表中是否存在，未找到查找依次往父类查找
4. 未找到进入消息动态转发过程

### 动态消息转发

> 当消息传递时无法找到可使用IMP则会进入此阶段

转发流程如下

其中需要实现`resolveInstanceMethod:` 或`resolveClassMethod: `方法

![](http://blog-imgs.nos-eastchina1.126.net/1645076321.png)

- 1.通过 resolveInstanceMethod 得知方法是否为动态添加，YES则通过 class_addMethod 动态添加方法，处理消息，否则进入下一步。dynamic 属性就与这个过程有关，当一个属性声明为 dynamic 时 就是告诉编译器：开发者一定会添加 setter/getter 的实现，而编译时不用自动生成。
- 2.这步会进入 forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则进入第三步。这种方式把消息原封不动地转发给目标对象，有着比较高的效率。如果不能自己的类里面找到替代方法，可以重载这个方法，然后把消息转给其他的对象。
- 3.这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 说明消息无法处理并报错 `unrecognized selector sent to instance`，如果返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 `unrecognized selector sent to instance`

在正常操作中我们可以用过以下代码进行方法执行异常处理

```objective-c
void dynamicMethodIMP(id self, SEL _cmd) { 
  	// 未实现方法处理记录
}

+ (BOOL) resolveInstanceMethod:(SEL)aSEL { 
		if (aSEL == @selector(resolveThisMethodDynamically)) { 
      	class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:"); 
      	return YES; 
    } 
  	return [super resolveInstanceMethod:aSel]; 
}
```

### 方法混淆

> 将某些方法的IMP指向做调整达到某些特定操作

主要方法`method_exchangeImplementations`和`class_replaceMethod`

+ **method_exchangeImplementations**: 用于交换两个方法的IMP函数指针
+ **class_replaceMethod**: 替换 某方法的IMP为指定函数指针

### 属性关联

> 在Category中是无法添加成员变量的，即使添加属性也只是默认提供setter、getter方法

因此利用setter、getter方法使用runtime动态关联对象和相关变量

+ `objc_setAssociatedObject` 为对象关联某个值
+ `objc_getAssociatedObject`获取对象的关联值

属性关联并不是为类添加了成员变量，而是使用另外的关联表来做k-v的管理

## Runloop

> RunLoop 实际上就是一个对象，提供一个函数入口提供“接受消息->等待->处理” 的循环，直到这个循环结束（比如传入 quit 的消息），函数返回

Runloop一般和线程相关联，可用于线程保活

苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()

### 相关类

**CFRunLoopRef**
**CFRunLoopModeRef**(未暴露使用CFRunLoopRef封装)
**CFRunLoopSourceRef** 事件产生（source0 非端口通信,硬件事件(触摸/锁屏/摇晃等), source1 端口通信,系统事件）
**CFRunLoopTimerRef** 基于时间的触发器
**CFRunLoopObserverRef** 观察者

一个RunLoop中包含若干Mode，每个Mode又包含Source/Timer/Observer

<img src="http://blog-imgs.nos-eastchina1.126.net/1645079875.png" style="zoom:75%;" />

### RunLoop内部逻辑
![](http://blog-imgs.nos-eastchina1.126.net/1645080856.png)

## Block

> block本质上也是一个OC对象，内部有isa指针

全局变量--不会捕获，是直接访问。

静态局部变量--是捕获变量地址。

普通局部变量--是捕获变量的值。

此时局部变量并未捕获age，函数内部age其实是一个副本

![](http://blog-imgs.nos-eastchina1.126.net/1645085690.png)

如果想持有捕获age需要使用`__block`修饰符，这样才会捕获age

## KVC和KVO

> 两者底层都是使用了runtime技术
>
> kvc在iOS13已经开始禁用

### KVC

> 使用key来动态获取或设置对象属性值
>
> 这里key是指成员变量名

使用`setValue:forKey:`时若无对应的set方法则会执行`+(BOOL)accessInstanceVariablesDirectly`方法

方法返回NO会执行`setValue: forUndefineKey:`方法，返回YES通过 _key 或 _isKey继续查找如都不存在执行

`setValue: forUndefineKey:`默认是抛出异常

### KVO

> 键值观察，即观察者模式

当一个对象被执行KVO后，其isa将会被指向一个动态创建的对象类子类，该子类重写了set方法和class方法

set方法执行时会在赋值前后执行willset和didset方法(这两个方法是触发KVO监听方法的关键)。

class方法会以父类(对象类)执行class方法

## Autorelease

> 自动释放池，可以理解为一个对象
> 在超出此对象生命周期后，会向其管理的对象实例发送release消息

**关键字**: `@autoreleasepool`

#### 结构体

`__AtAutoreleasePool`包含了：构造函数、析构函数和一个边界对象；

其内部是进行`AutoreleasePoolPage`的操作

```c
class AutoreleasePoolPage 
{
#   define EMPTY_POOL_PLACEHOLDER ((id*)1)
#   define POOL_BOUNDARY nil
    static pthread_key_t const key = AUTORELEASE_POOL_KEY;
    static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing
    static size_t const SIZE = 
#if PROTECT_AUTORELEASEPOOL
        PAGE_MAX_SIZE;  // must be multiple of vm page size
#else
        PAGE_MAX_SIZE;  // 4096字节 size and alignment, power of 2
#endif
    static size_t const COUNT = SIZE / sizeof(id);

    magic_t const magic; // 4*4字节 用来校验 AutoreleasePoolPage 的结构是否完整；
    id *next; // 8字节 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() ；
    pthread_t const thread; // 8字节 指向当前线程；
    AutoreleasePoolPage * const parent; // 8字节，指向父结点，第一个结点的 parent 值为 nil ；双向链表上一个节点
    AutoreleasePoolPage *child; //8字节, 指向子结点，最后一个结点的 child 值为 nil ；双向链表下一个节点
    uint32_t const depth; // 4字节，代表深度，从 0 开始，往后递增 1；
    uint32_t hiwat; // 4字节 ， 代表 high water mark 。
    //这几个加起来是56字节  
    ...
}
```



#### 实现逻辑

每个自动释放池都是由若干个`AutoreleasePoolPage`(每个大小4096字节)组成的双向链表

![](http://blog-imgs.nos-eastchina1.126.net/1645091784.png)



## 网络编程相关

### TCP

![](http://blog-imgs.nos-eastchina1.126.net/1645089854.png)

### https

单项认证

![](http://blog-imgs.nos-eastchina1.126.net/1645089937.png)

双向认证

![](http://blog-imgs.nos-eastchina1.126.net/1645090006.png)
